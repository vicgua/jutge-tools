# THIS FILE IS NOT INTENDED TO BE EDITED
# This Makefile is a general template; to configure it, edit the
# "build_conf.mk" file.
include build_conf.mk

# If your version of GNU tar is not named "tar", use "make TAR=gtar" (for
# example). Other versions such as BSD tar may also work, though.
TAR = tar
TARFLAGS += --owner=0 --group=0 --mode=0644  # Remove author information from
# the tar archive (modification time is preserved)

# Path to the doxygen executable
DOXYGEN = doxygen
# Flags passed to Doxygen (for example, an alternative Doxyfile)
DOXYGENFLAGS =
DOCSDIR = docs

# Internal variables to simplify the Makefile
DEPS.cc = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH)
DEPS.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)

enable_doxygen := {enable_doxygen}

# We keep a list of objects generated by make, so only these will be deleted
# when doing "make clean".
built-objs = $(BUILD_DIR)/built_objs
# This pattern convert spaces into new lines, appends ./ to every file and
# tries to escape shell strings. Any of this should not happen on normal
# conditions, but do it anyway, just for the sake of defensive programming
# (and to avoid reckless deleting of files).
# (Note: this pattern is autogenerated from the JutgeTools/data/safe.sed file
# in JutgeTools's source code, and adapted for Make. Check the original file
# for a more readable form)
sed-file = $(BUILD_DIR)/clean.sed
define sed-pattern :=
{sed_pattern}
endef
write-sed-file = ([ -f $(sed-file) ] || \
                  printf '%s\n' $(sed-pattern) > $(sed-file))
ifeq ($(ORDERED_BUILD_OBJECTS),false)
addobject = echo $(1) >> $(built-objs)
clean-bo = printf '%q\n' $$(sort -u $(built-objs) | sed -f $(sed-file))
prepare-build = mkdir -pv $(BUILD_DIR) && $(write-sed-file)
else
sort-bo = sort -uo $(built-objs)
addobject = echo $(1) | cat $(built-objs) - | $(sort-bo)
sed-bo := sed -s $(sed-pattern) $(built-objs)
clean-bo = printf '%q\n' $$(sed -f $(sed-file) $(built-objs))
prepare-build = mkdir -pv $(BUILD_DIR) && touch $(built-objs) \
                && $(write-sed-file)
endif

.PHONY: all
.DEFAULT: all
all: $(PROGRAMNAME) $(TARNAME) docs

.PHONY: clean
clean:
	@# The "read from file" is not the safest option, but is the easiest and
	@# most portable. Since this will run in YOUR system, you are responsible
	@# for having sanely named object files and not messing with
	@# $(BUILD_DIR)/built_objs
	@[ -f "$(built-objs)" ] && rm -v -- `$(clean-bo)` || true
	@rm -rvf "$(BUILD_DIR)"/*
	@[ -d "$(BUILD_DIR)" ] && rmdir -v "$(BUILD_DIR)" || true
	@[ "$(enable_doxygen)" = "true" ] && [ -d "$(DOCSDIR)" ] && \
		$(MAKE) -C "$(DOCSDIR)/latex" clean && \
		rm -rv "$(DOCSDIR)" || true

ifeq ($(enable_doxygen),true)
.PHONY: docs
docs:
	$(DOXYGEN) $(DOXYGENFLAGS)
	$(MAKE) -C $(DOCSDIR)/latex
else
docs:
endif

.PHONY: exe
exe: $(PROGRAMNAME)

.PHONY: tar
tar: $(TARNAME)

%.o: %.cc
	@$(prepare-build)
	@# The following command generates a dependency file, with the headers
	@# that the source depends on, so that it will be recompiled if the
	@# source or any of it headers change.
	$(DEPS.cc) -MM -MF $(BUILD_DIR)/$@.d $<
	$(COMPILE.cc) -o $@ $<
	@$(call addobject,$@)

%.o: %.c
	@$(prepare-build)
	$(DEPS.c) -MM -MF $(BUILD_DIR)/$@.d $<
	$(COMPILE.c) -o $@ $<
	@$(call addobject,$@)

$(PROGRAMNAME): $(OBJECTS)
	@$(prepare-build)
	$(LINK.cc)   -o $@ $^
	@$(call addobject,$@)

$(TARNAME): $(TARFILES)
	@$(prepare-build)
ifeq ($(TARAPPEND), true)
	$(TAR) $(TARFLAGS) -r -f $@ $?
else
	$(TAR) $(TARFLAGS) -c -f $@ $^
endif
	@$(call addobject,$@)

# Internal: Used by JutgeTools to get the executable name when testing
.PHONY: _exe_name
_exe_name:
	@printf '$(PROGRAMNAME)'

-include $(BUILD_DIR)/*.d
